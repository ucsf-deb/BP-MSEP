
harness_alloc.jl
  bigbigsim
bigbigsim.jl
    bigsim(nouter;..)
simulate.jl:75 (first one)
      simulate(nclusters...)
        LogisticSimpleEvaluator()
logistic_simple_evaluator.jl
	  creates structure using zSQdensity as one argument
	  zSQdensity is currently templated
simulate.jl (second one)
	simulate(ev; ...)
	  Threads.@spawn worker(command, ml, ev)
logistic_simple_evaluator.jl:211
	    wa = WorkArea(data, ev)  # also templated
	    zhat()
	    zsimp()

@code_warntype MSEP.worker(command, ml, ev)
MethodInstance for MSEP.worker(::Channel{Any}, ::MultiLevel, ::LogisticSimpleEvaluator{Float64})
  from worker(command::Channel, ml::MultiLevel, ev::LogisticSimpleEvaluator) in MSEP at c:\Users\rdboylan\Documents\BP\MSEP\src\logistic_simple_evaluator.jl:211Arguments
# even though LogisticSimpleEvaluator is a parameterized type, the parameter is not reported above
# that is consistent with the declaration of worker()
# Note the parameter does appear in the argument list below
  #self#::Core.Const(MSEP.worker)
  command::Channel{Any}
  ml::MultiLevel
  ev::LogisticSimpleEvaluator{Float64}
Locals
  wa::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
  #51::MSEP.var"#51#52"{MultiLevel}
  @_7::Any
# next 2 should be Float64.  So type from integral unknown.
  zs::Any
  zh::Any
# fairly naturally info from channel is unknown type
  iCluster::Any
  i1::Any
  i0::Any
Body::Nothing
1 ─ %1  = Base.getproperty(ml, :individuals)::DataFrame
└──       (wa = MSEP.WorkArea(%1, ev))
2 ┄       Core.typeassert(true, Core.Bool)
│         Core.NewvarNode(:(#51))
│         Core.NewvarNode(:(zs))
│         Core.NewvarNode(:(zh))
│   %7  = MSEP.take!(command)::Any
│   %8  = Base.indexed_iterate(%7, 1)::Any
│         (i0 = Core.getfield(%8, 1))
│         (@_7 = Core.getfield(%8, 2))  ### what's this?
│   %11 = Base.indexed_iterate(%7, 2, @_7)::Any
│         (i1 = Core.getfield(%11, 1))
│         (@_7 = Core.getfield(%11, 2))
│   %14 = Base.indexed_iterate(%7, 3, @_7)::Any
│         (iCluster = Core.getfield(%14, 1))
│   %16 = (i0 < 0)::Any
└──       goto #4 if not %16
3 ─       return nothing
4 ─       Base.setproperty!(wa, :i_start, i0)
│         Base.setproperty!(wa, :i_end, i1)
│         Base.setproperty!(wa, :i_cluster, iCluster)
│         (zh = MSEP.zhat(ev, wa))
│         (zs = MSEP.zsimp(ev, wa))
## var"#51#52" is a local function?
│   %24 = MSEP.:(var"#51#52")::Core.Const(MSEP.var"#51#52")
│   %25 = Core.typeof(ml)::Core.Const(MultiLevel)
│   %26 = Core.typeof(zs)::DataType
│   %27 = Core.typeof(zh)::DataType
│   %28 = Core.typeof(iCluster)::DataType
│   %29 = Core.apply_type(%24, %25, %26, %27, %28)::Type{MSEP.var"#51#52"{MultiLevel, _A, _B, _C}} where {_A, _B, _C}
│   %30 = zs::Any
│   %31 = zh::Any
│         (#51 = %new(%29, ml, %30, %31, iCluster))
│   %33 = #51::MSEP.var"#51#52"{MultiLevel}
│   %34 = Base.getproperty(ml, :cluster_lock)::ReentrantLock
│         MSEP.lock(%33, %34)
└──       goto #2
5 ─       Core.Const(:(return nothing))

@code_warntype MSEP.WorkArea(ml.individuals, ev)
MethodInstance for MSEP.WorkArea(::DataFrame, ::LogisticSimpleEvaluator{Float64})
  from MSEP.WorkArea(dat::DataFrame, ev::TEvaluator) where TEvaluator in MSEP at c:\Users\rdboylan\Documents\BP\MSEP\src\logistic_simple_evaluator.jl:88
Static Parameters
  TEvaluator = LogisticSimpleEvaluator{Float64}
Arguments
  #self#::Type{MSEP.WorkArea}
  dat::DataFrame
  ev::LogisticSimpleEvaluator{Float64}
Locals
  zip::UInt64
## I think next line indicates stable return type inferred correctly
Body::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
1 ─ %1 = Base.convert(MSEP.UInt, 0)::Core.Const(0x0000000000000000)
│        (zip = Core.typeassert(%1, MSEP.UInt))
│   %3 = Core.apply_type(MSEP.WorkArea, $(Expr(:static_parameter, 1)))::Core.Const(MSEP.WorkArea{LogisticSimpleEvaluator{Float64}})
│   %4 = Base.getproperty(dat, :Y)::AbstractVector
│   %5 = MSEP.work(ev)::Any
│   %6 = zip::Core.Const(0x0000000000000000)
│   %7 = zip::Core.Const(0x0000000000000000)
## oddly asymmetric handling of zips
│   %8 = (%3)(dat, %4, ev, %5, MSEP.WZ, %6, %7, zip::Core.Const(0x0000000000000000))::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
## return value has correct type
└──      return %8

@code_warntype zhat(ev, wa)
MethodInstance for MSEP.zhat(::LogisticSimpleEvaluator{Float64}, ::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}})
  from zhat(ev::LogisticSimpleEvaluator, wa::WorkArea) where WorkArea in MSEP at c:\Users\rdboylan\Documents\BP\MSEP\src\logistic_simple_evaluator.jl:179
# zhat is a parameterized function with WorkArea parameter
# I was worried about name collisions between WorkArea as a local parameter, struct name, and function,
# but it seems to have resolved correctly
Static Parameters
  WorkArea = MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
Arguments
  #self#::Core.Const(MSEP.zhat)
  ev::LogisticSimpleEvaluator{Float64}
  wa::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
Locals
  den::Any
  num::Any
  f::MSEP.var"#f#49"{LogisticSimpleEvaluator{Float64}, MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}}
# unknown return type
Body::Any
1 ─ %1  = MSEP.:(var"#f#49")::Core.Const(MSEP.var"#f#49")
│   %2  = Core.typeof(ev)::Core.Const(LogisticSimpleEvaluator{Float64})
│   %3  = Core.typeof(wa)::Core.Const(MSEP.WorkArea{LogisticSimpleEvaluator{Float64}})
│   %4  = Core.apply_type(%1, %2, %3)::Core.Const(MSEP.var"#f#49"{LogisticSimpleEvaluator{Float64}, MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}})
│         (f = %new(%4, ev, wa))
│         Base.setproperty!(wa, :objective, MSEP.WZ)
│   %7  = (:segbuf,)::Core.Const((:segbuf,))
│   %8  = Core.apply_type(Core.NamedTuple, %7)::Core.Const(NamedTuple{(:segbuf,)})
│   %9  = Base.getproperty(wa, :segs)::Any
│   %10 = Core.tuple(%9)::Tuple{Any}
│   %11 = (%8)(%10)::NamedTuple{(:segbuf,), _A} where _A<:Tuple{Any}
# integrator is untyped
│   %12 = Base.getproperty(ev, :integrator)::Any
│   %13 = Core.kwfunc(%12)::Any
│   %14 = Base.getproperty(ev, :integrator)::Any
│         (num = (%13)(%11, %14, f))
│         Base.setproperty!(wa, :objective, MSEP.justW)
│   %17 = (:segbuf,)::Core.Const((:segbuf,))
│   %18 = Core.apply_type(Core.NamedTuple, %17)::Core.Const(NamedTuple{(:segbuf,)})
│   %19 = Base.getproperty(wa, :segs)::Any
│   %20 = Core.tuple(%19)::Tuple{Any}
│   %21 = (%18)(%20)::NamedTuple{(:segbuf,), _A} where _A<:Tuple{Any}
│   %22 = Base.getproperty(ev, :integrator)::Any
│   %23 = Core.kwfunc(%22)::Any
│   %24 = Base.getproperty(ev, :integrator)::Any
│         (den = (%23)(%21, %24, f))
│   %26 = (num / den)::Any
└──       return %26


# from inside zhat
f(z) = ev.f(z, wa)
wa.objective = MSEP.WZ
@code_warntype ev.integrator(f, segbuf=wa.segs)
MethodInstance for (::Core.var"#Any##kw")(::NamedTuple{(:segbuf,), Tuple{Vector{QuadGK.Segment{Float64, Float64, Float64}}}}, ::AgnosticAGK, ::var"#f#6"{MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}, LogisticSimpleEvaluator{Float64}})
  from (::Core.var"#Any##kw")(::Any, aagk::AgnosticAGK, f) in MSEP at c:\Users\rdboylan\Documents\BP\MSEP\src\MSEP.jl:104
Arguments
  _::Core.Const(Core.var"#Any##kw"())
  @_2::NamedTuple{(:segbuf,), Tuple{Vector{QuadGK.Segment{Float64, Float64, Float64}}}}
  aagk::AgnosticAGK
  f::var"#f#6"{MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}, LogisticSimpleEvaluator{Float64}}
Locals
  segbuf::Vector{QuadGK.Segment{Float64, Float64, Float64}}
  @_6::Vector{QuadGK.Segment{Float64, Float64, Float64}}
Body::Any
1 ─ %1  = Base.haskey(@_2, :segbuf)::Core.Const(true)
│         Core.typeassert(%1, Core.Bool)
│         (@_6 = Base.getindex(@_2, :segbuf))
└──       goto #3
2 ─       Core.Const(:(@_6 = MSEP.nothing))
3 ┄ %6  = @_6::Vector{QuadGK.Segment{Float64, Float64, Float64}}
│         (segbuf = %6)
│   %8  = (:segbuf,)::Core.Const((:segbuf,))
│   %9  = Core.apply_type(Core.NamedTuple, %8)::Core.Const(NamedTuple{(:segbuf,)})
│   %10 = Base.structdiff(@_2, %9)::Core.Const(NamedTuple())
│   %11 = Base.pairs(%10)::Core.Const(Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}())
│   %12 = Base.isempty(%11)::Core.Const(true)
│         Core.typeassert(%12, Core.Bool)
└──       goto #5
4 ─       Core.Const(:(Base.kwerr(@_2, aagk, f)))
5 ┄ %16 = MSEP.:(var"#_#5")(segbuf, aagk, f)::Any
└──       return %16

# and ultimately this is what is evaluated for a single point
@code_warntype f(0.0)
MethodInstance for (::var"#f#7"{MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}, LogisticSimpleEvaluator{Float64}})(::Float64)
  from (::var"#f#7")(z) in Main at c:\Users\rdboylan\Documents\BP\MSEP\src\test1.jl:46
Arguments
  #self#::var"#f#7"{MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}, LogisticSimpleEvaluator{Float64}}
  z::Float64
Body::Any
1 ─ %1 = Core.getfield(#self#, :ev)::LogisticSimpleEvaluator{Float64}
│   %2 = Base.getproperty(%1, :f)::Any
│   %3 = Core.getfield(#self#, :wa)::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
│   %4 = (%2)(z, %3)::Any
└──      return %4

# same thing with less indirection is much more useful
# all the types look good
@code_warntype ev.f(0.0, wa)
MethodInstance for MSEP.zSQdensity(::Float64, ::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}})
  from zSQdensity(z::Float64, wa::TWorkArea) where TWorkArea in MSEP at c:\Users\rdboylan\Documents\BP\MSEP\src\logistic_simple_evaluator.jl:94
Static Parameters
  TWorkArea = MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
Arguments
  #self#::Core.Const(MSEP.zSQdensity)
  z::Float64
  wa::MSEP.WorkArea{LogisticSimpleEvaluator{Float64}}
Locals
  @_4::Union{Nothing, Tuple{UInt64, UInt64}}
  d::Float64
  objective::MSEP.Objective
  dat::DataFrame
  ev::LogisticSimpleEvaluator{Float64}
  i::UInt64
  cd::Float64
  Y::Bool
Body::Float64
1 ──       Core.NewvarNode(:(@_4))
│          Core.NewvarNode(:(d))
│          (ev = Base.getproperty(wa, :evaluator))
│    %4  = Base.getproperty(wa, :dat)::DataFrame
│    %5  = Base.convert(MSEP.DataFrame, %4)::DataFrame
│          (dat = Core.typeassert(%5, MSEP.DataFrame))
│    %7  = Base.getproperty(wa, :objective)::MSEP.Objective
│    %8  = Base.convert(MSEP.Objective, %7)::MSEP.Objective
│          (objective = Core.typeassert(%8, MSEP.Objective))
│    %10 = (objective == MSEP.justZ)::Bool
└───       goto #3 if not %10
2 ──       goto #4
3 ── %13 = (objective == MSEP.just1)::Bool
└───       goto #5 if not %13
4 ┄─ %15 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
│    %16 = (%15)()::Core.Const(Val{2}())
│    %17 = Base.literal_pow(MSEP.:^, z, %16)::Float64
│    %18 = (-0.5 * %17)::Float64
│          (d = MSEP.exp(%18))
└───       goto #6
5 ── %21 = Base.getproperty(ev, :λ)::Float64
│    %22 = (2.0 * %21)::Float64
│    %23 = (1.0 - %22)::Float64
│    %24 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
│    %25 = (%24)()::Core.Const(Val{2}())
│    %26 = Base.literal_pow(MSEP.:^, z, %25)::Float64
│    %27 = (-0.5 * %23 * %26)::Float64
└───       (d = MSEP.exp(%27))
6 ┄─ %29 = Base.getproperty(wa, :i_start)::UInt64
│    %30 = Base.getproperty(wa, :i_end)::UInt64
│    %31 = (%29:%30)::UnitRange{UInt64}
│          (@_4 = Base.iterate(%31))
│    %33 = (@_4 === nothing)::Bool
│    %34 = Base.not_int(%33)::Bool
└───       goto #12 if not %34
7 ┄─ %36 = @_4::Tuple{UInt64, UInt64}
│          (i = Core.getfield(%36, 1))
│    %38 = Core.getfield(%36, 2)::UInt64
│    %39 = Base.getproperty(wa, :Y)::BitVector
│          (Y = Base.getindex(%39, i))
│    %41 = Base.getproperty(ev, :σ)::Float64
│    %42 = (z * %41)::Float64
│    %43 = Base.getproperty(ev, :k)::Float64
│    %44 = (%42 + %43)::Float64
│          (cd = MSEP.logistic(%44))
└───       goto #9 if not Y
8 ──       (d = d * cd)
└───       goto #10
9 ── %49 = d::Float64
│    %50 = (1.0 - cd)::Float64
└───       (d = %49 * %50)
10 ┄       (@_4 = Base.iterate(%31, %38))
│    %53 = (@_4 === nothing)::Bool
│    %54 = Base.not_int(%53)::Bool
└───       goto #12 if not %54
11 ─       goto #7
12 ┄ %57 = (objective == MSEP.justZ)::Bool
└───       goto #14 if not %57
13 ─       goto #15
14 ─ %60 = (objective == MSEP.WZ)::Bool
└───       goto #16 if not %60
15 ┄       (d = d * z)
16 ┄       return d

# above seems to work well and is inconsistent with allocations I'm seeing
# even Y has proper type.

And here's the time without profiling after doing an initial iteration to compile:
julia> @time bigbigsim(10; nclusters=500);
Summary predictors for σ =0.25
7×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -1.76666    9.33296e-15  -0.438563   6.11086e-16
   2 │      1  -0.846583   1.8169e-14   -0.207592   8.96691e-16
   3 │      2   0.0457445  2.63312e-16   0.0229005  4.07116e-16
   4 │      3   0.914282   1.8968e-14    0.252926   4.85735e-15
   5 │      4   1.76357    1.06143e-14   0.482501   2.70611e-16
   6 │      5   2.59856    1.05091e-15   0.711641   2.12039e-16
   7 │      6   3.42445    5.0634e-16    0.940366   2.32882e-16

Summary predictors for σ =0.5
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -2.26547    1.73324e-14  -0.740417   1.18882e-14
   2 │      1  -1.04528    1.58015e-14  -0.354563   6.08359e-15
   3 │      2  -0.0153731  1.97623e-16   0.0229187  4.72997e-16
   4 │      3   0.897033   1.07163e-14   0.393002   4.51188e-15
   5 │      4   1.74902    1.06691e-14   0.756826   5.82266e-15
   6 │      5   2.58768    2.70079e-16   1.11566    1.98773e-16
   7 │      6   3.45779    3.33067e-16   1.47086    4.191e-16
   8 │      7   4.40954    0.0           1.82387    0.0

Summary predictors for σ =0.75
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -2.34377    3.19936e-14  -0.90723    1.7441e-14
   2 │      1  -0.993942   7.32326e-15  -0.43276    2.77645e-15
   3 │      2  -0.0418906  1.22762e-15   0.0103556  1.9977e-16
   4 │      3   0.729599   3.62599e-15   0.429355   8.45896e-15
   5 │      4   1.43402    2.55953e-15   0.831709   5.07639e-15
   6 │      5   2.14915    9.88246e-15   1.2248     1.43808e-15
   7 │      6   2.95821    3.88141e-15   1.6159     8.93578e-16
   8 │      7   3.99588    4.57757e-16   2.0122     9.15513e-16

Summary predictors for σ =1.0
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp        zsimp_sd    
     │ UInt16  Float64     Float64      Float64      Float64     
─────┼───────────────────────────────────────────────────────────
   1 │      0  -2.32201    5.73186e-14  -0.990838    1.14415e-14
   2 │      1  -0.892384   1.19955e-14  -0.463378    6.12538e-15
   3 │      2  -0.0475961  1.12568e-15  -0.00221081  3.60511e-17
   4 │      3   0.593401   1.07123e-16   0.415056    2.8127e-15
   5 │      4   1.17266    7.11231e-15   0.80766     2.33632e-15
   6 │      5   1.77711    1.3149e-15    1.19234     4.93402e-15
   7 │      6   2.5149     7.17526e-15   1.58494     2.06345e-15
   8 │      7   3.63323    8.96844e-16   2.00221     2.69053e-15

Summary predictors for σ =1.25
8×5 DataFrame
 Row │ ∑Y      zSQ        zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64    Float64      Float64     Float64     
─────┼─────────────────────────────────────────────────────────
   1 │      0  -2.27838   2.48809e-14  -1.02971    2.26594e-14
   2 │      1  -0.792358  6.55339e-15  -0.466916   6.43531e-15
   3 │      2  -0.04628   9.24993e-17  -0.0110569  1.16843e-16
   4 │      3   0.494167  6.01382e-15   0.383628   5.17579e-15
   5 │      4   0.979923  1.27164e-14   0.749578   4.78001e-15
   6 │      5   1.49682   5.29602e-16   1.11218    7.12608e-15
   7 │      6   2.16567   1.2463e-14    1.49597    1.33532e-15
   8 │      7   3.35486   8.4774e-15    1.93076    3.34634e-15

  0.864329 seconds (2.50 M allocations: 80.965 MiB, 2.99% gc time)

In contrast, with the code from 924143c7572f2adf0699bd07732c377b668c4bf7 it was
julia> @time bigbigsim(10; nclusters=500);
Summary predictors for σ =0.25
7×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -1.76666    9.33358e-15  -0.438563   2.38895e-15
   2 │      1  -0.846583   1.72737e-14  -0.207592   2.00801e-15
   3 │      2   0.0457445  5.65646e-16   0.0229005  4.38348e-16
   4 │      3   0.914282   1.92977e-14   0.252926   4.91077e-15
   5 │      4   1.76357    1.12686e-14   0.482501   3.04084e-16
   6 │      5   2.59856    1.02588e-15   0.711641   2.5602e-16
   7 │      6   3.42445    7.50648e-16   0.940366   4.59676e-16

Summary predictors for σ =0.5
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -2.26547    1.77766e-14  -0.740417   1.19992e-14
   2 │      1  -1.04528    1.55779e-14  -0.354563   6.0837e-15
   3 │      2  -0.0153731  1.97232e-16   0.0229187  4.83772e-16
   4 │      3   0.897033   1.06104e-14   0.393002   4.28934e-15
   5 │      4   1.74902    9.78031e-15   0.756826   5.71585e-15
   6 │      5   2.58768    2.96059e-16   1.11566    8.33667e-16
   7 │      6   3.45779    2.76938e-16   1.47086    6.11463e-16
   8 │      7   4.40954    0.0           1.82387    0.0

Summary predictors for σ =0.75
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64     Float64      Float64     Float64     
─────┼──────────────────────────────────────────────────────────
   1 │      0  -2.34377    3.19937e-14  -0.90723    1.73299e-14
   2 │      1  -0.993942   2.20972e-15  -0.43276    3.44057e-16
   3 │      2  -0.0418906  1.22806e-15   0.0103556  2.01298e-16
   4 │      3   0.729599   6.51195e-15   0.429355   8.01556e-15
   5 │      4   1.43402    3.66831e-15   0.831709   5.18347e-15
   6 │      5   2.14915    8.54582e-15   1.2248     1.01744e-15
   7 │      6   2.95821    3.90469e-15   1.6159     4.46725e-16
   8 │      7   3.99588    9.27672e-16   2.0122     4.63836e-16

Summary predictors for σ =1.0
8×5 DataFrame
 Row │ ∑Y      zSQ         zSQ_sd       zsimp        zsimp_sd    
     │ UInt16  Float64     Float64      Float64      Float64     
─────┼───────────────────────────────────────────────────────────
   1 │      0  -2.32201    5.86509e-14  -0.990838    1.15524e-14
   2 │      1  -0.892384   1.22175e-14  -0.463378    6.45737e-15
   3 │      2  -0.0475961  1.11899e-15  -0.00221081  3.61275e-17
   4 │      3   0.593401   1.06602e-16   0.415056    2.42345e-15
   5 │      4   1.17266    8.44565e-15   0.80766     2.34525e-15
   6 │      5   1.77711    3.58552e-15   1.19234     3.15794e-15
   7 │      6   2.5149     8.08854e-15   1.58494     2.29648e-15
   8 │      7   3.63323    0.0           2.00221     2.24445e-15

Summary predictors for σ =1.25
8×5 DataFrame
 Row │ ∑Y      zSQ        zSQ_sd       zsimp       zsimp_sd    
     │ UInt16  Float64    Float64      Float64     Float64     
─────┼─────────────────────────────────────────────────────────
   1 │      0  -2.27838   2.62133e-14  -1.02971    1.97711e-14
   2 │      1  -0.792358  5.66488e-15  -0.466916   6.10271e-15
   3 │      2  -0.04628   9.22828e-17  -0.0110569  1.60943e-16
   4 │      3   0.494167  5.73587e-15   0.383628   5.06357e-15
   5 │      4   0.979923  1.33984e-14   0.749578   4.55952e-15
   6 │      5   1.49682   5.1824e-16    1.11218    7.11088e-15
   7 │      6   2.16567   1.15739e-14   1.49597    4.4515e-16
   8 │      7   3.35486   8.47816e-15   1.93076    3.12353e-15

  9.223643 seconds (397.69 M allocations: 6.060 GiB, 33.74% gc time)

In short, before was
  9.223643 seconds (397.69 M allocations: 6.060 GiB, 33.74% gc time)
and now more than 10x faster, allocations >150x better, memory use > 70x better.
  0.864329 seconds (2.50 M allocations: 80.965 MiB, 2.99% gc time)
