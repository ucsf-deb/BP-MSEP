        - 
        - """
        - MultiLevel holds 2 DataFrames, one with individuals
        - as rows as one with clusters as row.
        - 
        - The cid's, cluster ids, should be the same for both.
        - 
        - Although the structure is read-only, expected use is that 
        - columns will be added to the contained data, esp for clusters.
        - 
        - Writing to DataFrame's is not thread-safe.  Since anticipated
        - use involved writing to clusters from multiple threads, we provide a
        - lock which all clients should use when updating clusters.
        - """
        - struct MultiLevel
        -     individuals::DataFrame
        -     clusters::DataFrame
        -     cluster_lock::ReentrantLock
        - end
        - 
        - function MultiLevel(individuals::DataFrame, clusters::DataFrame)
        -     MultiLevel(individuals, clusters, ReentrantLock())
        - end
        - 
        - """
        -     maker(nclusters=3, nclustersize=4, k=-2.0, σ=1.0)
        - 
        - Return a <MultiLevel> generated by a simple mixed model for binary outcomes with the indicated sizes and parameters.
        - Cluster random effects are N(0, σ) and the only fixed effect is the intercept k.
        - Y binary outcome
        - cid cluster id
        - sid subject id (unique across all clusters)
        - The id's are currently integers, but perhaps should be Categorical.
        - MixedModels formula syntax says cluster ids should be Categorical,
        - but in their examples it's actually String.
        - 
        - All the following are usually unobserved
        - z true random effect (constant within cluster)
        - η true value on the linear scale
        - p true probability of success
        - 
        - Output individuals has one row per subject in anticipation of subject-level
        - variables
        - """
        0 function maker(; nclusters=3, nclustersize=4, k=-2.0, σ=1.0)::MultiLevel
     4160     zcluster = rand(Normal(0.0, 1.0), nclusters)
        0     clusters = DataFrame(z=zcluster, cid=1:nclusters, n=nclustersize)
        -     # df below uses clusters.cid in the constructor.  Goal is to preserve
        -     # whatever scheme I come up with, e.g., still works if I change to
        -     # Categorical variables for IDs.  However, the groupby at the end
        -     # may change the type of cid anyway.
        - 
        -     # if we have variable cluster sizes, get individual cids with
        -     # cid = cat(map((id, n)->repeat([id], n), clusters.cid, clusters.n))
        -     # and similarly with z
      272     df = DataFrame(cid=repeat(clusters.cid, inner=nclustersize),
        -         sid=1:(nclusters*nclustersize),
        -         z=repeat(zcluster, inner=nclustersize))
        -     # The remaining elements depend on all previous ones,
        -     # and DataFrames doesn't seem good at that.  It doesn't work
        -     # in transform.
        - 
        -     # Since every member of the cluster is identical, the following
        -     # procedure is a bit inefficient.  But in the future there will be 
        -     # individual covariates, and this is the right flow for that.
       48     df.η = k .+ σ .* df.z
       16     df.p = logistic.(df.η)
       16     df.Y = rand.(Bernoulli.(df.p))
        - 
        -     # compute total successes in cluster
        -     # this assumes order unchanged, which may not be guaranteed
       16     clusters.∑Y = combine(groupby(df, :cid), :Y => sum => :∑Y)[:, :∑Y]
        - 
      112     return MultiLevel(df, clusters)
        - end
        - 
